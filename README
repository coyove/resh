resh is a single-threaded (goroutine) epoll based HTTP/Websocket/Redis server library written in pure Golang.
It acts as an HTTP (Websocket) server and a Redis server (RESP protocol) all in one, multiplex them on the same port.

resh is battle tested - this repo is derived from the internal codebase in Construct (https://constructfuture.com/),
capable of handling 10K QPS per core with real online traffic and business (Accessing to MongoDB, caching in Redis, requesting other services).

epoll/kqueue code in internal/ credit to the evio (https://github.com/tidwall/evio) project.
Some changes are made, such as the lock-free linked list. They will be merged into the upstream soon in the future.

- Usage -
resh is simple. Refer to /examples/allservers.go for its API.

- Should I? -
resh is reactive, if your logic requires starting a new goroutine for every request, then resh serves no benefits. You have to write all biz code
in a non-blocking way and process data in callbacks.
We have inhouse async Redis and HTTP client SDK, it will be open sourced as soon as we clean up all the infrastructure related stuff.

- Why Redis (RESP) -
To build an RPC service, we favor RESP over HTTP as the interface, because it is simple to implement, efficient to transfer,
and Redis-like commands are way more expressive than HTTP.

- About SSL -
OpenSSL and cgo are needed to enable SSL support, currently still in experimental state.

- Pipeline -
resh does not support pipelining deliberately, as it is mainly used as an RPC interface, RTT is negligible compared to an actual Redis server.
